package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.71

import (
	"context"
	"fmt"
	"gin_todo/graph/middlewares"
	"gin_todo/graph/model"
	"gin_todo/internal/handler/dto/request"
	"net/http"
	"strconv"
	"time"

	validator "github.com/go-playground/validator/v10"
)

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, data model.Todo) (*model.Message, error) {
	intID, err := strconv.ParseInt(data.ID, 10, 32)
	if err != nil {
		return &model.Message{
			Msg: fmt.Sprintf("ID is not a number: %s", data.ID),
		}, fmt.Errorf("ID is not a number: %s", data.ID)
	}
	v := validator.New()
	dto := request.CreateTaskRequest{
		UserID: int32(intID),
		Tasks:  data.Tasks,
	}
	if err := v.Struct(dto); err != nil {
		return &model.Message{
			Msg: fmt.Sprintf("Validation error: %s", err.Error()),
		}, fmt.Errorf("Validation error: %s", err.Error())
	}
	err = r.TaskUseCase.CreateTask(dto.UserID, dto.Tasks)
	if err != nil {
		return &model.Message{
			Msg: fmt.Sprintf("Create task error: %s", err.Error()),
		}, fmt.Errorf("Create task error: %s", err.Error())
	}
	return &model.Message{Msg: "Success!"}, nil
}

// ChangeTaskStatus is the resolver for the changeTaskStatus field.
func (r *mutationResolver) ChangeTaskStatus(ctx context.Context, data model.ChangeStatus) (*model.Message, error) {
	intID, err := strconv.ParseInt(data.ID, 10, 32)
	if err != nil {
		return &model.Message{
			Msg: fmt.Sprintf("ID is not a number: %s", data.ID),
		}, fmt.Errorf("ID is not a number: %s", data.ID)
	}
	v := validator.New()
	dto := request.ChangeTaskStatusRequest{
		TaskID:    int32(intID),
		IsChecked: data.IsChecked,
	}
	if err := v.Struct(dto); err != nil {
		return &model.Message{
			Msg: fmt.Sprintf("Validation error: %s", err.Error()),
		}, fmt.Errorf("Validation error: %s", err.Error())
	}
	err = r.TaskUseCase.ChangeTaskStatus(int32(intID), data.IsChecked)
	if err != nil {
		return &model.Message{
			Msg: fmt.Sprintf("Change task status error: %s", err.Error()),
		}, fmt.Errorf("Change task status error: %s", err.Error())
	}
	return &model.Message{Msg: "Success!"}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, data model.LoginData) (*model.Message, error) {
	token, err := r.UserUseCase.Login(data.UserName, data.Password)
	if err != nil {
		return &model.Message{
			Msg: fmt.Sprintf("Login error: %s", err.Error()),
		}, fmt.Errorf("Login error: %s", err.Error())
	}
	ca := middlewares.ForContext(ctx)
	cookie := new(http.Cookie)
	cookie.Name = "auth-cookie"
	cookie.Value = token
	cookie.Expires = time.Now().Add(2 * time.Hour)
	cookie.Path = "/"
	cookie.Domain = "localhost"

	// HttpOnlyをtrueにすることで、JavaScriptからクッキーにアクセスできなくなる
	cookie.HttpOnly = true
	cookie.Secure = true
	cookie.SameSite = http.SameSiteStrictMode
	http.SetCookie(ca.Writer, cookie)
	return &model.Message{Msg: "Login success!"}, nil
}

// GetTasks is the resolver for the getTasks field.
func (r *queryResolver) GetTasks(ctx context.Context, id string) ([]*model.Tasks, error) {
	userCtx := middlewares.ForContext(ctx)
	if userCtx.UserName == "" {
		return nil, fmt.Errorf("ログインしていません")
	}
	intID, err := strconv.ParseInt(id, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("ID is not a number: %s", id)
	}
	tasks, err := r.TaskUseCase.GetTasks(int32(intID))
	if err != nil {
		return nil, fmt.Errorf("Get tasks error: %s", err.Error())
	}
	if len(tasks) == 0 {
		return nil, fmt.Errorf("No tasks found for user ID: %d", intID)
	}

	// entityのTasksをGraphQLのTasksに変換
	var result []*model.Tasks
	for _, task := range tasks {
		result = append(result, &model.Tasks{
			ID:        strconv.Itoa(int(task.ID)),
			Task:      task.Tasks,
			IsChecked: task.IsChecked,
		})
	}
	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
